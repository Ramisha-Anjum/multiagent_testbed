#!/usr/bin/python3

# other libraries
import math
import numpy as np

# package module
from pose_fusion.utils import PoseDataSynthesizer
from pose_fusion.spatial import Transformation
from pose_fusion.conversion import matrix_to_quaternion, euler_to_quaternion

# RCLPY libraries, classes, functions
import rclpy
from rclpy.node import Node

# ROS Packages
from tf2_msgs.msg import TFMessage
from geometry_msgs.msg import TransformStamped
from nav_msgs.msg import Odometry


class FakePosePublisher(Node):
    """A ROS2 node that publishes synthetic poses with corresponding transforms.

    This node publishes a `TFMessage` topic containing multiple `TransformStamped`
    messages that describe synthetic poses generated by `PoseDataSynthesizer`.
    Additionally, it publishes a `Odometry` topic containing the ground truth pose.

    Args:
        None
    """
    def __init__(self):

        super().__init__('fake_pose_publisher')
        # Declare a parameter 'num_pose' with default value of 10
        self.declare_parameter('num_pose',value=10)
        # Set the timer period to 0.1 seconds and create the timer
        timer_period = 0.1
        self.timer = self.create_timer(timer_period,self.timer_callback)

        # Create ROS2 publishers for the `TFMessage` and `Odometry` topics
        self.pub = self.create_publisher(TFMessage,'tf',10)
        self.odom_pub = self.create_publisher(Odometry,'ground_truth',10)

        # Record the initial time in seconds since epoch
        sec,nanosec = self.get_clock().now().seconds_nanoseconds()
        self.init_time = sec+nanosec/1e9
    def timer_callback(self):
        # Get the current time in seconds since epoch
        sec,nanosec = self.get_clock().now().seconds_nanoseconds()
        t = sec+nanosec/1e9-self.init_time

        # Synthesize nominal periodic motion
        f = 1/5
        x = math.cos(2*math.pi*f*t)
        y = math.sin(2*math.pi*f*t)
        z = math.sin(2*math.pi*0.2*f*t)
        Y = 2*math.pi*f*t
        f = 1/2.5
        R = 0.0
        P = math.pi/2*math.cos(2*math.pi*f*t)
        
        T = Transformation(rotation=euler_to_quaternion(R,P,Y),translation= [x,y,z]) 
        
        # Generate multiple measurements of the synthesized pose
        # by applying uncertainties to the nominal transform
        cov = np.diag([0.01,0.01,0.01,0.05,0.05,0.05])
        num_meas_poses = self.get_parameter('num_pose').value
        
        transforms,covariance_matrices = PoseDataSynthesizer.synthesize(
            nominal_pose=T.matrix(),
            covariance=cov,
            num=num_meas_poses
        )

        # collection of poses
        msg = TFMessage()
        # Publish the ground truth pose data as an Odometry message.
        ground_truth = Odometry()
        ground_truth.header.stamp = self.get_clock().now().to_msg()
        ground_truth.header.frame_id = 'world'
        ground_truth.child_frame_id = 'ground_truth'
        q = matrix_to_quaternion(T.matrix()[0:3,0:3])
        ground_truth.pose.pose.orientation.w = q[0]
        ground_truth.pose.pose.orientation.x = q[1]
        ground_truth.pose.pose.orientation.y = q[2]
        ground_truth.pose.pose.orientation.z = q[3]
        ground_truth.pose.pose.position.x = T.matrix()[0][3]
        ground_truth.pose.pose.position.y = T.matrix()[1][3]
        ground_truth.pose.pose.position.z = T.matrix()[2][3]
        self.odom_pub.publish(ground_truth)
        
        # Publish the entire collection of transforms
        for i in range(len(transforms)):
            transform = TransformStamped()
            transform.header.stamp = self.get_clock().now().to_msg()
            transform.header.frame_id = 'world'
            transform.child_frame_id = 'pose_'+str(i)
            q = matrix_to_quaternion(transforms[i][0:3,0:3])
            transform.transform.rotation.w = q[0]
            transform.transform.rotation.x = q[1]
            transform.transform.rotation.y = q[2]
            transform.transform.rotation.z = q[3]
            transform.transform.translation.x = transforms[i][0][3]
            transform.transform.translation.y = transforms[i][1][3]
            transform.transform.translation.z = transforms[i][2][3]
            msg.transforms.append(transform)
        self.pub.publish(msg)

# Define the main function that will run when this script is execute
def main(args=None):
    rclpy.init(args=args)
    node = FakePosePublisher()
    try:
        while rclpy.ok(): # while the node isn't shut down
            rclpy.spin_once(node)
    except KeyboardInterrupt:
        node.get_logger().info('Node has stopped cleanly.')
    except SystemExit:
        node.get_logger().info('Node is complete.')
    except BaseException as exc:
        type = exc.__class__.__name__
        node.get_logger().error(f'{type} exception in node has occured.')
        raise # raise without argument = raise the last exception
    finally:
        node.destroy_node()
        rclpy.shutdown() 

# If this script is being run as the main program, call the main function
if __name__=='__main__':
    main()
